BasicUpstart2(startup)

// ------------------------------------------------------------
//
// Import program data into known memory.
//
// ------------------------------------------------------------
.label ADR_DATA = $2000
.label DATA_BLOCK = ADR_DATA/64
*=ADR_DATA "Program Data"
#import "data.asm"


// ------------------------------------------------------------
//
// Import standard libraries and main program.
//
// ------------------------------------------------------------
*=$4000 "Main Program"
#import "c64lib.asm"
#import "c64sprite.asm"
#import "main.asm"


// ------------------------------------------------------------
//
// Declare local variables.
//
// ------------------------------------------------------------
_num_ticks:   .byte $00
_num_vblanks: .byte $00


// ------------------------------------------------------------
//
// Implement a generic startup and frame tracker.
//
// ------------------------------------------------------------
startup:
    sei        // disable maskable IRQs

    lda #$7f
    sta $dc0d  // disable timer interrupts which can be generated by the two CIA chips
    sta $dd0d  // the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
               // stop it.

    lda $dc0d  // by reading this two registers we negate any pending CIA irqs.
    lda $dd0d  // if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
               // we don't want that to happen.

    lda #$81   // this is how to tell the VICII to generate a raster interrupt
    sta $d01a

    lda #$80   // this is how to tell at which rasterline we want the irq to be triggered
    sta $d012

    lda #$1b   // as there are more than 256 rasterlines, the topmost bit of $d011 serves as
    sta $d011  // the 9th bit for the rasterline we want our irq to be triggered.
               // here we simply set up a character screen, leaving the topmost bit 0.

    lda #$35   // we turn off the BASIC and KERNAL rom here
    sta $01    // the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
               // SID/VICII/etc are visible

    lda #<irq  // this is how we set up
    sta $fffe  // the address of our interrupt code
    lda #>irq
    sta $ffff

    jsr main_init

    cli        // enable maskable interrupts again
    jmp main


irq:
    enter_irq()
    jsr main_irq
    leave_irq()
    rti        // Return From Interrupt, this will load into the Program Counter register the address
               // where the CPU was when the interrupt condition arised which will make the CPU continue
               // the code it was interrupted at also restores the status register of the CPU


// ------------------------------------------------------------
//
// Helper macros to track screen refresh and game loop.
//
// ------------------------------------------------------------
.macro count_vblank()
{
    dec _num_vblanks
    bpl end // return if less than a second

    lda #$32
    cmp _num_ticks
    beq !+
    lda #RED
    jmp !++
!:
    lda #GREEN
!:
    sta C64__COLOR

    print_byte(_num_ticks, 38, 0)
    lda #$31
    sta _num_vblanks
    lda #$00
    sta _num_ticks

end:
}

.macro wait_vblank() {
!:  // in case the raster is on our marker line, we wait for it increment
    lda C64__RASTER_LINE
    cmp #$fa
    beq !- 

!:  // wait for the raster to reach our marker line 
    lda C64__RASTER_LINE
    cmp #$fa // line 250
    bne !-    
}

.macro sync_tick(cnt)
{
    ldx #cnt
!:
    wait_vblank()
    dex
    bpl !-
    inc _num_ticks
}
